\section{Simulation Evaluation} \label{sec:simulation}

We have developed a simulation framework for comparing schedules generated from \textsc{STAM} and \textsc{STFU} task lists to schedules generated from non-smoothed task lists.  Our simulation includes a stochastic energy harvesting process, a random task list and \textsc{STAM}/\textsc{STFU} task list generator, the scheduling processes, and an execution process.  We execute $n$ simulations on one task list per run, and generate task lists for $r$ runs.  Each task list consists of $k$ tasks.

\subsection{Task Generation}
The tasks are generated with random periods, durations, and energy requirements.  The periods and durations are distributed uniformly in discrete time steps measured in days, ranging respectively from 10 to 40 and from 1 to 4.  The energy is half-normally distributed, and proportional to the task's period (\emph{i.e.} a task requiring high energy is expected to run at a low frequency).

A random task list and its corresponding virtual task list generated by \textsc{STAM} and \textsc{STFU} are generated reiteratively until both lists are temporally schedulable.  We consider a task list temporally schedulable when its CPU utilization $U$ (from equation \ref{eqn:utilization} is less than 100\%.  We assume that the physical task list has less than 50% utilization, to better demonstrate our work.

\subsection{Energy Harvesting Model}
We use a simple model of a photovoltaic energy harvester, which converts solar irradiance $G$ into a current $I_c$, as a stochastic energy source for our simulation.  The energy withdrawn from the environment is modeled as a 3-state Markov chain (\cite{poggi2000stochastic,moser2007real}) representing three weather conditions (figure~\ref{fig:markov}).  At each discrete time step during the simulation the Markov chain is updated, and the energy generated added to an energy pool (\emph{i.e.} a battery).
\begin{figure}[htb]
\begin{center}
\label{fig:markov}
\caption{Markov Chain Weather Model.}
\includegraphics[scale=0.8]{markov.png}
\end{center}
\end{figure}
We generated a table of energy inputs to the system using the solar cell model that comes with Simulink's SimElectronics toolkit, configured with values from \cite{gonzalez2006model}.  
\begin{table}[h]
\begin{center}
\begin{tabular}{| l | l || l | l |}
\hline
\textbf{$G$ ($\frac{W}{m^2}$)} & \textbf{$I_c$ ($A$)} & \textbf{$G$ ($\frac{W}{m^2}$)} & \textbf{$I_c$ ($A$)} \\
\hline
50 & 0.190 & 175 & 0.665 \\
75 & 0.285 & 200 & 0.760 \\
100 & 0.380 & 225 & 0.855 \\
125 & 0.475 & 250 & 0.950 \\
150 & 0.570 & 275 & 1.045 \\
\hline
\end{tabular}
\end{center}
\label{tab:radiance}
\caption{Solar panel energy output}
\end{table}
The solar cell's current output with a battery load is related to its radiation input by the linear function $I_c = 0.0038G$.  We use the values of $G = 50, 100, 200 \frac{W}{m^2}$ to represent the stormy, cloudy, and sunny weather conditions in our weather model.

The output current of the photovoltaic cell, $I_c$, is governed by a two-diode formula given in \cite{marwali1997probabilistic} and modeled by the Simulink model.  The current flows into a battery, for which we use a linear model without relaxation effect.  The battery capacity at time $t$, $B_t$ is calculated using equation~\ref{eqn:batterycharge} per \cite{niyato2007sleep}.
\begin{equation}
 B_t = B_{t-1} + I_c \Delta t - I_d \Delta t
\label{eqn:batterycharge}
\end{equation}
where 
\begin{description}
\item[$B_{t-1}$] is the previous battery capacity
\item[$I_c$] is the charge current due to solar harvesting during $\Delta t$
\item[$I_d$] is the discharge current due to task execution during $\Delta t$
\end{description}
We represent $I_c$ and $I_d$  as constant averages during the interval $\Delta t$. Furthermore, the battery is
limited in capacity, such that if $B_t = B_{max}$ then any excess energy that is harvested is lost.

\subsection{Simulation Results}
We performed 1000 runs, with one run consisting of 100 simulations each on several task schedules using common random numbers (\emph{i.e.} using the same weather patterns).  Each simulation covered a period of 100 time units, and if the battery charge dropped to 0 during the simulation we incremented a violation counter.  We recorded the number of violations produced during each run.  

Figure \ref{XXXX} shows the average number of violations that each algorithm we tried produced over 100 simulations, as a function of utilization.

We used earliest-deadline-first (\textsc{EDF}) and as-late-as-possible (\textsc{ALAP}) scheduling to schedule real tasks, \textsc{STAM} virtual tasks, and \textsc{STFU} virtual tasks (\textsc{STFU} only applies to \textsc{EDF} since high-utilization task lists are hard to schedule with the other algorithms).  In \textsc{EDF}, each task is scheduled as early as possible, in order of increasing deadline.  In \textsc{ALAP}, tasks are scheduled at the latest time possible such that no task misses its deadline.  \textsc{ALAP} is an energy-ignorant version of \textsc{LSA}, which means that it can be scheduled statically without a sophisticated energy prediction model.  

In table \ref{tab:simresults} we show simulation results for statically scheduled systems, and for systems that support dynamic re-scheduling.  The static simulation routine executes each task as it appears in the input schedule.  The dynamic simulator monitors the battery's energy level and, if the battery is at its maximum capacity (\emph{i.e.} harvested energy cannot be stored), tries to re-schedule a task to run immediately.  Our focus in this paper is on static scheduling, but we present results for dynamic scheduling as well.

Our version of \textsc{LSA} is based on the \textsc{LSA-I} algorithm proposed by Moser \emph{et al.} \cite{moser2007real}.  Their work focuses on dynamic scheduling with energy prediction, but we include results for \textsc{LSA-I} for comparison\footnote{Their description of \textsc{LSA-II} is very similar to our implementation of dynamically scheduled \textsc{LSA}, but theirs is further refined via the energy input prediction.}.  To create a static \textsc{LSA} schedule we pre-process an \textsc{ALAP} schedule using our dynamic simulation routine, with a constant minimal energy input in place of the stochastic input.  This constant input is the prediction we give to \textsc{LSA}.  As a result, in \textsc{LSA} tasks will be statically rescheduled when the model can guarantee that the battery is at maximum capacity, \emph{e.g.} at the start of the simulation before any tasks have run.  Energy may still be wasted in the static-schedule, stochastic simulation model when the battery reaches its maximum capacity unexpectedly.  The only way to avoid that would be to predict the energy input while generating the static schedule.
\begin{table}[h]
\begin{center}
\begin{tabular}{| l l | l l |}
\hline
\multicolumn{2}{|c|}{\textbf{Static}} & \multicolumn{2}{|c|}{\textbf{Dynamic}} \\
\textbf{Algorithm} & \textbf{Viol. Rate} & \textbf{Algorithm} & \textbf{Viol. Rate} \\
\hline
EDF & 5.22 & EDF & 5.22 \\
EDF \textsc{STAM} & 4.55 & EDF \textsc{STAM} & 4.44 \\
EDF \textsc{STFU} & 2.36 & EDF \textsc{STFU} & 1.60 \\
ALAP & 2.07 & ALAP & 0.45 \\
ALAP \textsc{STAM} & 1.82 & ALAP \textsc{STAM} & 0.46 \\
LSA & 1.40 & LSA & 0.45 \\
LSA \textsc{STAM} & 1.10 & LSA \textsc{STAM} & 0.46 \\
\hline
\end{tabular}
\end{center}
\label{tab:simresults}
\caption{Violations per 100 simulations for various algorithms with and without dynamic task rescheduling.}
\end{table}
Table~\ref{tab:simresults} shows the simulation results for the scheduling algorithms we tested.  As expected, \textsc{EDF}---the optimal periodic scheduling algorithm in systems with unlimited energy---results in the most violations.  Schedules generated by applying the \textsc{EDF} scheduler to the virtual task lists generated by the \textsc{STAM} and \textsc{STFU} algorithms perform better.  Scheduling \textsc{STFU} virtual tasks using \textsc{EDF} results in a significant improvement over plain \textsc{EDF}, approaching the performance of the more complex scheduling algorithms.

The \textsc{ALAP} and \textsc{LSA} static schedulers performed much better than the \textsc{EDF}-based algorithms.  Task lists with high utilization are difficult to schedule with \textsc{ALAP}, so we did not schedule \textsc{STFU} virtual tasks with \textsc{ALAP}.  Using \textsc{STAM} virtual tasks to generate \textsc{ALAP} and \textsc{LSA} schedules improves the results even more.

In the dynamic simulator, \textsc{ALAP} and \textsc{LSA} perform equally well, since our version of \textsc{LSA} is equivalent to \textsc{ALAP} pre-processed with the dynamic simulator.  The dynamic simulations result is a very low violation rate because the model can detect and respond when the battery reaches full capacity unexpectedly.  Running \textsc{ALAP} and \textsc{LSA} on \textsc{STAM} tasks produces slightly worse results than on physical tasks.  This is a result of the small idle time inserted before the physical tasks, which causes energy to be wasted when a \textsc{STAM} task is rescheduled.





































